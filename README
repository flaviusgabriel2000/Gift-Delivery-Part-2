// Gift Delivery - Part 2


        For the 2nd stage of the project, I started the implementation from the code
written in the first stage and added new functionalities, but also small improvements.
As new functionalities, I introduced in the classes that handle the input fields for
the quantity of gifts and the elves assigned to each child. As improvements, I made
changes to several methods already implemented (calculating the average score, updating
information about children, assigning gifts to children, etc.).
        For the design and organization part, the project was created
using 4 design patterns:
            - The simulation was implemented using the  Strategy design pattern
(a strategy that simulates round 0 and a strategy for the next  numberOfYears years).
The interface and the two classes that provide the implementation of the interface
are in the solver.strategies.simulationstrategy package;
            - In the 2nd stage, the gift assignment strategies for each annual change
were also implemented using Strategy, only this time I decided to combine it with
the Factory design pattern, in order to be able to generate objects based on the type
of strategy given in the input. The class that handles this part is AssignStrategyFactory
from the solver.strategies.assignstrategy package, and the actual implementations are
also in this package;
            - For the Child class in solver.simulate, I came up with a change in the
structure from stage 1 and decided to implement it using the Builder design pattern. 
Also, niceScoreBonus was implemented using Builder;
            - The serialization part of the results obtained from the simulation is
handled by the Output class from the solver.simulate.output package, which is implemented
using the Singleton design pattern.


        Identical to step 1, parsing the input data and writing the output
is done using the Jackson library together with the ObjectMapper class
which translates information from JSON into objects and vice versa.